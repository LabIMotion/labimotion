# frozen_string_literal: true
require 'export_table'
require 'labimotion/version'

module Labimotion
  ## ExportDataset
  class ExportDataset
    DEFAULT_ROW_WIDTH = 100
    DEFAULT_ROW_HEIGHT = 20

    def initialize(**args)
      @xfile = Axlsx::Package.new
      @file_extension = 'xlsx'
      @xfile.workbook.styles.fonts.first.name = 'Calibri'
    end

    def res_name(id)
      element_name = Container.find(id)&.root_element&.short_label
      ols = ols_name(id)
      "#{element_name}_#{ols.gsub(' ', '_')}.xlsx"
    rescue StandardError => e
      Labimotion.log_exception(e)
    end

    def ols_name(id)
      ds = Labimotion::Dataset.find_by(element_id: id, element_type: 'Container')
      return nil if ds.nil?

      name = ds.dataset_klass.label

      match = name.match(/\((.*?)\)/)
      name = match && match.length > 1 ? match[1] : name

      name = '1H NMR' if ds.dataset_klass.ols_term_id == 'CHMO:0000593'
      name = '13C NMR' if ds.dataset_klass.ols_term_id == 'CHMO:0000595'
      name.slice(0, 26)
    rescue StandardError => e
      Labimotion.log_exception(e)
      'ols_name'
    end

    def description(ds, id)
      wb = @xfile.workbook
      sheet = @xfile.workbook.add_worksheet(name: 'Description')
      header_style = sheet.styles.add_style(sz: 12, fg_color: 'FFFFFF', bg_color: '00008B', border: { style: :thick, color: 'FF777777', edges: [:bottom] })
      sheet.add_row(['File name', res_name(id)])
      sheet.add_row(['Time', Time.now.strftime("%Y-%m-%d %H:%M:%S %Z")] )
      sheet.add_row(['(This file is automatically generated by the system.)'])
      sheet.add_row([''])
      sheet.add_row([''])
      sheet.add_row(['Fields description of sheet:' + ds.dataset_klass.label])
      sheet.add_row(['Fields', 'Field description'], style: header_style)
      sheet.add_row(['Layer Label', 'The label of the layer'])
      sheet.add_row(['Field Label', 'The label of the field'])
      sheet.add_row(['Value', 'The current value of the field'])
      sheet.add_row(['Unit', 'The unit of the field'])
      sheet.add_row(['Name', 'The key of the field, can be used to identify the field'])
      sheet.add_row(['Type', 'The type of the field'])
      sheet.add_row(['Source?', '[Device] from device, [Chemotion] from Chemotion'])
      sheet.add_row(['Source identifier', 'The source identifier'])
      sheet.add_row(['Source data', 'The data from Device or Chemotion, cannot be modified once a generic dataset is created'])
      sheet.add_row([''])
      sheet.add_row([''])
    rescue StandardError => e
      Labimotion.log_exception(e)
    end

    def export(id)
      ds = Labimotion::Dataset.find_by(element_id: id, element_type: 'Container')
      return if ds.nil?

      description(ds, id)

      wb = @xfile.workbook
      name = ols_name(id)
      return if name.nil?

      sheet = @xfile.workbook.add_worksheet(name: name)
      sheet.add_row([ds.dataset_klass.label])
      header_style = sheet.styles.add_style(sz: 12, fg_color: 'FFFFFF', bg_color: '00008B', border: { style: :thick, color: 'FF777777', edges: [:bottom] })
      layer_style = sheet.styles.add_style(b: true, bg_color: 'CEECF5')
      sheet.add_row(header, style: header_style)

      layers = ds.properties[Labimotion::Prop::LAYERS] || {}
      options = ds.properties[Labimotion::Prop::SEL_OPTIONS]
      layer_keys = layers.keys.sort_by { |key| layers[key]['position'] }
      layer_keys.each do |key|
        layer = layers[key]
        sheet.add_row([layer['label'], ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '], style: layer_style)
        sorted_fields = layer[Labimotion::Prop::FIELDS].sort_by { |obj| obj['position'] }
        sorted_fields.each do |field|
          next if field['type'] == 'dummy'

          type = field['type']
          from_device = field['device'].present? ? 'Device' : ''
          from_device = field['system'].present? ? 'Chemotion' : from_device
          type = "#{field['type']}-#{field['option_layers']}" if field['type'] == Labimotion::FieldType::SELECT || field['type'] == Labimotion::FieldType::SYSTEM_DEFINED

          show_value = field['value'] =~ /\A\d+,\d+\z/ ? field['value']&.gsub(',', '.') : field['value']
          sheet.add_row([' ', field['label'], nil, field['value_system'], field['field'], type, from_device, field['dkey'], nil].freeze)

          case field['type']
          when Labimotion::FieldType::SELECT
            sheet.rows.last.cells[2].type = :string
            sheet.rows.last.cells[8].type = :string
            show_value = opt_value(field, options) if show_value.present?
          when Labimotion::FieldType::SYSTEM_DEFINED, Labimotion::FieldType::INTEGER
            sheet.rows.last.cells[2].type = :float
            sheet.rows.last.cells[8].type = :float
          else
            sheet.rows.last.cells[2].type = :string
            sheet.rows.last.cells[8].type = :string
          end
          sheet.rows.last.cells[2].value = show_value
          sheet.rows.last.cells[8].value = field['system'] || field['device']


        end
        # sheet.column_widths nil, nil, nil, nil, 0, 0, 0, 0, 0
      end
    rescue StandardError => e
      Labimotion.log_exception(e)
    end

    def opt_value(field, options)
      return nil if field.nil? || options.nil? || field['value']&.empty? || field['option_layers']&.empty?
      return nil unless opts = options.fetch(field['option_layers'], nil)&.fetch('options', nil)

      selected = opts&.find { |ss| ss['key'] == field['value'] }
      selected&.fetch('label', nil) || field['value']
    rescue StandardError => e
      Labimotion.log_exception(e)
      field['value']
    end

    def spectra(id)
      name_mapping = []
      wb = @xfile.workbook
      gds = Labimotion::Dataset.find_by(element_id: id, element_type: 'Container')
      cds = Container.find(id)
      cds_csv = cds.attachments.where(aasm_state: 'csv').order(:filename)
      csv_length = cds_csv.length
      return if csv_length.zero?
      cds_csv.each_with_index do |att, idx|
        sheet_name = "Sheet#{idx+1}"
        sheet = @xfile.workbook.add_worksheet(name: sheet_name)
        name_mapping.push([sheet_name, att.filename])
        File.open(att.attachment_url) do |fi|
          fi.each_line do |line|
            sheet.add_row(line.split(','))
          end
        end
      end

      if name_mapping.length > 1
        first_sheet = @xfile.workbook.worksheets&.first
        header_style = first_sheet&.styles.add_style(sz: 12, fg_color: 'FFFFFF', bg_color: '00008B', border: { style: :thick, color: 'FF777777', edges: [:bottom] })
        first_sheet&.add_row(['Sheet name', 'File name'], style: header_style)
        name_mapping&.each do |mapping|
          next if mapping.length < 2

          @xfile.workbook.worksheets&.first&.add_row([mapping[0].to_s, mapping[1].to_s])
        end
      end

    end

    def header
      ['Layer Label', 'Field Label', 'Value', 'Unit', 'Name', 'Type', 'Source?', 'Source identifier', 'Source data'].freeze
    end

    def read
      @xfile.to_stream.read
    end

  end
end
